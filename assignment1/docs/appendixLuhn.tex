Der findes mange måder at implementere en Luhn checksum algoritme på, herunder især hvordan talrækken bliver transformeret. I denne opgave er implementeringen givet ved en talrække af \(n\) cifre, som kan itereres igennem baglæns med et index der går fra 0 til \(n\). Hvorvidt indexets numeriske værdi er et lige eller ulige tal, afgør hvorvidt cifferet skal fordobles. Hvis det fordoblede tal er højere end 9, så vil det resultere i et 2-cifret, hvorfor det fordoblede tal ikke længere kan bruges.

For at løse denne sidste problematik, tages det fordoblede tal i modulus 10, hvorefer 1 lægges til. En alternativ måde at tænke om det på, kunne være at man tager det første ciffer i det fordoblede tal, og lægger til det andet ciffer. Ligeledes findes der også en alternativ, og mere imperativ (mindre matematisk rigid), formulering til hvordan talrækken af cifre kan itereres, hvor der ikke tages højde for indexets paritet: start med det næstsidste ciffer i rækken, og påfør transformationen på hver anden næste kommende ciffer, gående fra højre mod venstre.

Uanset implementeringen, bliver resultatet dog ens. Her er selvfølgelig forsøgt at skabe nøjagtigt den implementering som er beskrevet i opgaven. Den store udfordring ved netop denne implementering i kode er, at der er to forskellige indexer, som går i hver deres retning: optælling og nedtælling. Talrækken skal itereres baglæns, mens indexet i hver iteration stiger postivt med optælling.

En løsning kunne være at sortere talrækken før og efter transformationen, men det ville ikke være særligt effektivt mht. evalueringstid. Derfor itereres der i en løkke over et positivt stigende index, hvorfra det negativt aftagende index til talrækken kan udledes og beregnes, da længen af talrækken / arrayet kendes. \nameref{appendix}
